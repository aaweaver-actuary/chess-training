# chess-trainer web UI

The web client provides a daily training dashboard for the chess-trainer workspace. It visualises
progress metrics, contextual recommendations, and upcoming unlocks generated by the scheduling
pipeline. The application is written in React + TypeScript and is instrumented with Vitest, Testing
Library, ESLint, and Prettier to guarantee 100% coverage and consistent formatting.

## Features

- **Daily Review Summary** – exposes due/completed/remaining cards and accuracy percentage.
- **Recommendation Engine** – surfaces actionable guidance based on backlog pressure and accuracy
  health, driven by the `ReviewPlanner` domain service.
- **Upcoming Unlocks** – highlights the next three moves or tactics the scheduler will introduce.
- **Deterministic Styling** – gradient shell and badges that match backlog/accuracy state.

## Local development

```bash
npm install
npm run dev
```

Visit `http://localhost:5173` and the dashboard will load the built-in sample snapshot.

### Sample PGN

For smoke testing the opening board, a small PGN lives at `public/samples/training-sample.pgn`:

```
1. h3 h6 2. h4 h5 3. e3 e6 4. Ke2 Ke7
```

You can import it into any chess GUI to confirm that the board accepts manual moves end-to-end.

## Quality gates

The project follows a strict test-first workflow. The commands below are composed inside the
workspace `Makefile` and can also be run individually during development:

```bash
npm run format:check   # Prettier conformance
npm run lint           # ESLint with type-aware rules
npm run typecheck      # TypeScript `--noEmit`
npm run test:coverage  # Vitest with 100% coverage thresholds
```

## Testing philosophy

- All domain logic lives in `src/services/ReviewPlanner.ts` and is covered by scenario-based unit
  tests.
- UI components are validated with Testing Library to enforce accessibility semantics.
- Coverage thresholds are pinned to 100% for statements, branches, lines, and functions.

## File layout

```
src/
├── App.tsx                # App shell + sample snapshot
├── components/
│   └── ReviewDashboard.tsx # Presentational dashboard component
├── services/
│   └── ReviewPlanner.ts    # Domain logic and recommendations
└── setupTests.ts           # Vitest + Testing Library configuration
```

## Extending the UI

1. **Add data sources** – replace the static snapshot with API calls (REST, GraphQL, WebSocket).
2. **Integrate scheduling** – wire the dashboard to the Rust scheduler output.
3. **Improve visualisations** – introduce charts (e.g., `victory`, `recharts`) for streak or
   accuracy trends.
4. **State management** – as the application grows, promote the planner into a context provider or
   state machine (e.g., XState) to maintain SOLID boundaries.
